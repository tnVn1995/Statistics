# Simulate data to test the power of the statistical test
## ----
new_data = matrix(0, nrow=500, ncol=6)

# Generate marginal probabilities for W_i
pi_R = c(0.4,0.6)
fun = function(p)((p/(0.4-p))/((0.5-p)/(0.1+p)) - 2)
pw.11 = uniroot(fun, lower=0.0, upper = 1.0)$root
pw.10 = 0.4 - pw.11
pw.01 = 0.5 - pw.11
pw.00 = 0.1 + pw.11
pw.11 + pw.10 + pw.01 + pw.00

# Generate marginal probabilities for Y_i
pi_C = c(0.2, 0.3)
py.11 = 0.085
py.10 = 0.2 - py.11
py.01 = pi_C[2] - py.11
py.00 = 0.5 + py.11
py.11 + py.00 + py.10 + py.01
# shuffle W - Alternative therapies probabilities
orderw = cbind(c(11,10,01,00),c(pw.11,pw.10,pw.01,pw.00))
orderw1 = orderw[sample(nrow(orderw)),]
orderw2 = cbind(orderw1, cumsum(orderw1[,2]))

# shuffle Y - Recommendation sources probabilities
ordery = cbind(c(11,10,01,00),c(py.11,py.10,py.01,py.00))
ordery1 = ordery[sample(nrow(ordery)),]
ordery2 = cbind(ordery1, cumsum(ordery1[,2])) 


#----
# Simulate data using computed marginal probabilities
simulated_data = matrix(NA, nrow=500, ncol=6)
colnames(simulated_data) = c('W1','W2','Y11','Y12','Y21','Y22')
generate_y = function(proby, data, Uy, row, pos1){
  #' @description Generate simulated data for the Y variable using specified probabilities
  #' @param proby matrix. A 1x3 matrix containing cumulative probability and its corresponding cluster
  #' @param data matrix. A 1x6 empty matrix to store data simulated for the Y variables
  #' @param Uy decimal. A decimal number randomly generated from a uniform distribution.
  #' @param pos1 integer. Integer numbers specifying columns to fill in data
  #' @param row integer. Interger number specifying the row to fill in data
  #' @usage generate_y(proby, data, Uy)
  #' @return a 500x6 matrix that contains simulated data from Y
  if (Uy >= proby[1,3] & Uy < proby[2,3]){
    data[row,] = 0
  } else if (Uy >= proby[2,3] & Uy < proby[3,3]){
    data[row, pos1] = 1
    data[row, pos1+1] = 0
  } else if (Uy >= proby[3,3] & Uy < proby[4,3]){
    data[row, pos1] = 1
    data[row, pos1+1] = 1 
  } else {
    data[row, pos1] = 0
    data[row, pos1+1] = 1
  }
  return(data)
}
generate_cluster = function(probw,proby, data, Uw, Uy1, Uy2, i, pos1, pos2, row){
#' @description Generate simulated data for W using spcified probabilities
#' @param probw,proby matrix. A 1x3 matrix containing cumulative probability and its corresponding cluster
#' @param data matrix. A 500x6 empty matrix to store simulated data
#' @param Uw,Uy1,Uy2 float. A float number generated from a uniform distribution
#' @param pos1,pos2 integer. Numbers specifying the columns to fill in the data with
#' @param i integer. A number specifying the row to fill in the data with
#' @usage generated_cluster(prob, data, U)
#' @return a 500x6 matrix that contains simulated data 
  if (Uw >= probw[1,3] & Uw < probw[2,3]){
    data[i,1] = 0
    data[i,2] = 0
    data[i,3:6] = NA
  }
  else if (Uw >= probw[2,3] & Uw < probw[3,3]){
    data[i, 1] = 1
    data[i, 2] = 0
    data = generate_y(proby, data, Uy1,row=i, pos1)
  }
  else if (Uw >= probw[3,3] & Uw < probw[4,3]){
    data[i, 1] = 1
    data[i, 2] = 1
    data = generate_y(proby, data, Uy1, row=i, pos1)
    data = generate_y(proby, data, Uy2, row=i, pos2)
  }
  else {
   data[i,1] = 0
   data[i,2] = 1
   data = generate_y(proby, data, Uy2, row=i, pos2)
  }
  return (data)
} 
count = 0
while (count < 500){
  Uw = runif(1, 0, 1)
  Uy1 = runif(1, 0, 1)
  Uy2 = runif(1, 0, 1)
  simulated_data = generate_cluster(probw = orderw2, proby = ordery2, Uw = Uw, Uy1=Uy1, Uy2=Uy2, i= count+1, pos1=3, pos2=5, data=simulated_data)
  count=count+1
}
# Change the order of columns to reflect the true order of the data due to the way Y's were generated
simulated_data[,c(1,2,3,4,5,6)] = simulated_data[,c(1,2,3,5,4,6)]