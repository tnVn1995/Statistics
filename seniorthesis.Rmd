---
title: "Senior Thesis"
author: "Tung Nguyen"
date: "2/9/2020"
output:
  pdf_document: default
  html_document: default
  word_document: default
---
```{r include=FALSE}
knitr::opts_chunk$set(echo=FALSE)
```

```{r, warning=FALSE}
# The dependencies
library(foreign)
# library(tidyverse)
# install.packages("magrittr") # package installations are only needed the first time you use it
# install.packages("dplyr")    # alternative installation of the %>%
library(magrittr) # needs to be run every time you start R and want to use %>%
library(testit)
```


# Generate Data for Simulation Experiment


```{r}
# knitr::opts_chunk$set(echo=FALSE, warning=TRUE)

# Simulate data to test the power of the statistical test
## ----
# new_data = matrix(0, nrow=500, ncol=6)

# Generate marginal probabilities for W_i
pi_R = c(0.4,0.6)
fun = function(p)((p/(0.4-p))/((0.5-p)/(0.1+p)) - 2)
pw.11 = uniroot(fun, lower=0.0, upper = 1.0)$root
pw.10 = 0.4 - pw.11
pw.01 = 0.5 - pw.11
pw.00 = 0.1 + pw.11
pw.11 + pw.10 + pw.01 + pw.00

# Generate marginal probabilities for Y_i
pi_C = c(0.2, 0.3)
py.11 = 0.085
py.10 = 0.2 - py.11
py.01 = pi_C[2] - py.11
py.00 = 0.5 + py.11
py.11 + py.00 + py.10 + py.01
# shuffle W - Alternative therapies probabilities
orderw = cbind(c(11,10,01,00),c(pw.11,pw.10,pw.01,pw.00))
orderw1 = orderw[sample(nrow(orderw)),]
orderw2 = cbind(orderw1, cumsum(orderw1[,2]))

# shuffle Y - Recommendation sources probabilities
ordery = cbind(c(11,10,01,00),c(py.11,py.10,py.01,py.00))
ordery1 = ordery[sample(nrow(ordery)),]
ordery2 = cbind(ordery1, cumsum(ordery1[,2])) 


#-------------------------------------
# Simulate data using computed marginal probabilities
simulated_data = matrix(NA, nrow=500, ncol=6)
colnames(simulated_data) = c('W1','W2','Y11','Y12','Y21','Y22')
generate_y = function(proby, data, Uy, row, pos1){
  #' @description Generate simulated data for the Y variable using specified probabilities
  #' @param proby matrix. A 1x3 matrix containing cumulative probability and its corresponding cluster
  #' @param data matrix. A 1x6 empty matrix to store data simulated for the Y variables
  #' @param Uy decimal. A decimal number randomly generated from a uniform distribution.
  #' @param pos1 integer. Integer numbers specifying columns to fill in data
  #' @param row integer. Interger number specifying the row to fill in data
  #' @usage generate_y(proby, data, Uy)
  #' @return a 500x6 matrix that contains simulated data from Y
  if (Uy >= proby[1,3] & Uy < proby[2,3]){
    data[row,pos1] = 0
    data[row, pos1+1] = 0
  } else if (Uy >= proby[2,3] & Uy < proby[3,3]){
    data[row, pos1] = 1
    data[row, pos1+1] = 0
  } else if (Uy >= proby[3,3] & Uy < proby[4,3]){
    data[row, pos1] = 1
    data[row, pos1+1] = 1 
  } else {
    data[row, pos1] = 0
    data[row, pos1+1] = 1
  }
  return(data)
}
generate_cluster = function(probw,proby, data, Uw, Uy1, Uy2, i, pos1, pos2, row){
#' @description Generate simulated data for W using spcified probabilities
#' @param probw,proby matrix. A 1x3 matrix containing cumulative probability and its corresponding cluster
#' @param data matrix. A 500x6 empty matrix to store simulated data
#' @param Uw,Uy1,Uy2 float. A float number generated from a uniform distribution
#' @param pos1,pos2 integer. Numbers specifying the columns to fill in the data with
#' @param i integer. A number specifying the row to fill in the data with
#' @usage generated_cluster(prob, data, U)
#' @return a 500x6 matrix that contains simulated data

  if (Uw >= probw[1,3] & Uw < probw[2,3]){
    data[i,1] = 0
    data[i,2] = 0
    data[i,3:6] = NA
  }
  else if (Uw >= probw[2,3] & Uw < probw[3,3]){
    data[i, 1] = 1
    data[i, 2] = 0
    data = generate_y(proby, data, Uy1,row=i, pos1)
  }
  else if (Uw >= probw[3,3] & Uw < probw[4,3]){
    data[i, 1] = 1
    data[i, 2] = 1
    data = generate_y(proby, data, Uy1, row=i, pos1)
    data = generate_y(proby, data, Uy2, row=i, pos2)
  }
  else {
   data[i,1] = 0
   data[i,2] = 1
   data = generate_y(proby, data, Uy2, row=i, pos2)
  }
  return (data)
}

# Simulating Data for Experiment
simulate_data = function(n=500){
count = 0
while (count < n){
  Uw = runif(1, 0, 1)
  Uy1 = runif(1, 0, 1)
  Uy2 = runif(1, 0, 1)
  simulated_data = generate_cluster(probw = orderw2, proby = ordery2, Uw = Uw, Uy1=Uy1, Uy2=Uy2, i= count+1, pos1=3, pos2=5, data=simulated_data)
  count=count+1
}
# Change the order of columns to reflect the true order of the data due to the way Y's were generated
simulated_data[,c(1,2,3,4,5,6)] = simulated_data[,c(1,2,3,5,4,6)]
}

simulated_data = simulate_data()

cat('The first five rows of simulated data:\n\n')
print(simulated_data[1:5,])
# Save simulated data to file
write.csv(simulated_data, file = 'simulated_data.csv', row.names = FALSE)
```
# Generating bootstrapping data
```{r, include=FALSE}
data = simulated_data
X = 2
n = dim(data)[1]
end = dim(data)[2]
W = sample(x=1:n,size=n,replace=TRUE)
Y = sample(x=1:n,size=n,replace = TRUE)
data.star = cbind(data[W,1:X],data[Y,(X+1):end])
# Turn all w's answers of zero into nan-values
zeros = which(data.star[,c(1,2)] == 0, arr.ind = TRUE)

```

```{r}
library(data.table)
data.nonan = copy(data.star)
data.nonan[zeros[,1],(therap+1+(zeros[,2]-1)*rec):(therap+ zeros[,2]*rec)] = NA
print(data.nonan[1:10,])
cat('\n\n\n\n')
print(data.star[1:10,])
```


# Calculate results using formulas:

$X^2_{M} = n \sum^r_{i=1}\sum^c_{j=1}\frac{(\bar \pi_{ij} - \bar \pi_{i.} \bar\pi_{.j})^2}{\bar \pi_{i.} \bar\pi_{.j}}$

## Calculate $\pi_{ij}$ and $pi_{.i}$
```{r}
## Calculate pi_ij, pi_i., pi_.j
therap = 2
rec = 2
therap=therap
rec=rec
n=500

y_ij = matrix(0, nrow=therap, ncol=rec)
n_ij = matrix(0, nrow=therap, ncol=rec)
y_nj = matrix(0,nrow=1,ncol=rec)
n_nj = matrix(0,nrow=1,ncol=rec)
pi_ij = function(data, therap, rec){
  i_count1= matrix(0, nrow=1, ncol=therap)
  ij_count1 = matrix(0, nrow=therap, ncol = rec)
  notij_count1 = matrix(0, nrow=therap, ncol = rec)
# start2 = proc.time()
for (i in 1:therap){
  yindx = which(data[,i]==1)
  i_count1[,i] = length(yindx)

  for (j in 1:rec){
  for (yindi in yindx){
        if (data[yindi,therap+i+(j-1)*rec]==1){
          ij_count1[i,j] = ij_count1[i,j] + 1
        }
    else{
        notij_count1[i,j] = notij_count1[i,j] + 1
    }
    ycond = data[yindi,(therap+1+(j-1)*rec):(therap+ j*rec)]==1
    ncond = data[yindi,(therap+1+(j-1)*rec):(therap+ j*rec)]==0
    # the numerator is the number of y's or no's
    ynj_numerator = sum(ycond[which(!is.na(ycond))])
    nnj_numerator = sum(ncond[which(!is.na(ncond))])
    assert('should not be nan values', !is.na(ynj_numerator))
    assert('Should not be nan values', !is.na(nnj_numerator))
    assert("Your .j count is not correct!", ynj_numerator + nnj_numerator == y_denominator)
    if (){
    # Count the individuals who specify their jth recommendation source choice
    y_nj[,j] = y_nj[,j] + ynj_numerator / y_denominator
    n_nj[,j] = n_nj[,j] + nnj_numerator / y_denominator
    }
  }
    }
}
return(list(i_count=i_count1, ij_count=ij_count1, notij_count=notij_count1, Ws=yind))
}
yindi = 2
j = 1
cat(data[yindi,(therap+1+(j-1)*rec):(therap+ j*rec)]==1)

```

```{r}
### Calculate pi_.j
## Initialize variables with res = pi_ij(data, therap, rec)
therap = 2
rec = 2
therap=therap
rec=rec
n=500

y_ij = matrix(0, nrow=therap, ncol=rec)
n_ij = matrix(0, nrow=therap, ncol=rec)
y_nj = matrix(0,nrow=1,ncol=rec)
n_nj = matrix(0,nrow=1,ncol=rec)
for (i in 1:therap){
# y_denominator = sum(data[indi,1:therap]==1)
# #assert("Cannot be zero", y_denominator != 0)
# if (y_denominator == 0){
#   next()
  yind = which(data[,i]==1)
}
  for (j in 1:rec){
    # Count the individuals who pick jth recommendation source
    # Only count when that individual specifies their ith therapy pick
    # first remove na from consideration
    ycond = data[indi,(therap+1+(j-1)*rec):(therap+ j*rec)]==1
    ncond = data[indi,(therap+1+(j-1)*rec):(therap+ j*rec)]==0
    # the numerator is the number of y's or no's 
    ynj_numerator = sum(ycond[which(!is.na(ycond))])
    nnj_numerator = sum(ncond[which(!is.na(ncond))])
    assert('should not be nan values', !is.na(ynj_numerator))
    assert('Should not be nan values', !is.na(nnj_numerator))
    assert("Your .j count is not correct!", ynj_numerator + nnj_numerator == y_denominator)
    # Count the individuals who specify their jth recommendation source choice
    y_nj[,j] = y_nj[,j] + ynj_numerator / y_denominator
    n_nj[,j] = n_nj[,j] + nnj_numerator / y_denominator
  }

```


```{r}
###------------------------------------------------------------------------------------------
temp_X_cal= function(data, therap, rec){
  # In this dataset, 1 means yes and 0 means no
  therap=therap
  rec=rec
  n=500
  # i count matrices
  i_count= matrix(0, nrow=1, ncol=therap)
  pi_i.= matrix(0, nrow=1, ncol=therap)
  # ij count matrices
  ij_count = matrix(0, nrow=therap, ncol = rec)
  notij_count = matrix(0, nrow=therap, ncol = rec)
  # The count of individuals who pick jth recommendation source
  y_nj = matrix(0,nrow=1,ncol=rec)
  n_nj = matrix(0,nrow=1,ncol=rec)
  # The prob estimation of y_nj and n_nj
  yp_.j =  matrix(0,nrow=1,ncol=rec)
  np_.j =  matrix(0,nrow=1,ncol=rec)
  no = 2 #dimension of the matrix
  for (indi in 1:n){
    for (i in 1:therap){
      if (data[indi,i]==0)
        next
      else {
        # Counting the number of individuals who pick jth therapy to calculate pi_.i
        i_count[,i] = i_count[,i] + 1
        # Iterating through each therapy, count the participants who pick the jth recommendation to calculate pi_ij
        for (j in 1:rec){
          if (data[indi,therap+i+(j-1)*rec]==1){
            ij_count[i,j] = ij_count[i,j] + 1
          }
          else {
            notij_count[i,j] = notij_count[i,j] + 1
            # Remember to check to sum of ij_count 
          }
          
        }
        
      }
    }
    # for the real dataset, use sum of not nan values
    y_denominator = sum(data[indi,1:therap]==1)
    #assert("Cannot be zero", y_denominator != 0)
    if (y_denominator == 0){
      next()
    }
    else {
      for (j in 1:rec){
        # Count the individuals who pick jth recommendation source
        # Only count when that individual specifies their ith therapy pick
        # first remove na from consideration
        ycond = data[indi,(therap+1+(j-1)*rec):(therap+ j*rec)]==1
        ncond = data[indi,(therap+1+(j-1)*rec):(therap+ j*rec)]==0
        # the numerator is the number of y's or no's 
        ynj_numerator = sum(ycond[which(!is.na(ycond))])
        nnj_numerator = sum(ncond[which(!is.na(ncond))])
        assert('should not be nan values', !is.na(ynj_numerator))
        assert('Should not be nan values', !is.na(nnj_numerator))
        assert("Your .j count is not correct!", ynj_numerator + nnj_numerator == y_denominator)
        # Count the individuals who specify their jth recommendation source choice
        y_nj[,j] = y_nj[,j] + ynj_numerator / y_denominator
        n_nj[,j] = n_nj[,j] + nnj_numerator / y_denominator
      }
    }
  }
  # Sanity check of the count
  assert("The number of ijth pick is not correct!", ij_count+notij_count == matrix(rep(colSums(data[,c(1:therap)]),times=rec), nrow=therap, ncol=rec))
  assert('THe number of ith pick is not correct!', i_count == colSums(data[,c(1:therap)]))
  pi_i. = i_count / n
  # the grand total proportion of yeses and nos for the ith, jth and ijth values
  yp_.j = y_nj / n
  np_.j = n_nj / n
  ypi_ij = ij_count / n
  npi_ij = notij_count / n
  # Grand-test stat
  yp_grandstat = sum((ypi_ij - t(pi_i.) %*% yp_.j)^2 / (t(pi_i.) %*% yp_.j))
  np_grandstat = sum((npi_ij - t(pi_i.) %*% np_.j)^2 / (t(pi_i.) %*% np_.j))
  return (list(grandstat = (yp_grandstat + np_grandstat) * n, yes_stat = yp_grandstat, no_stat = np_grandstat))
}
```

# Bootstrapping Method

```{r} 
### Need to parallelize the codes here
cal_p_boot = function(data, X, B.max=1999, FUN=cal_X_squ){
  stat = FUN(data=data)
  X.sq.S.star = numeric(length(B.max))
  counter = 0
  b = 0
  while(b <= B.max){
    b = b+1
    n = dim(data)[1]
    end = dim(data)[2]
    W = sample(x=1:n,size=n,replace=TRUE)
    Y = sample(x=1:n,size=n,replace = TRUE)
    data.star = cbind(data[W,1:X],data[Y,(X+1):end])
    stat.star = FUN(data.star)
    
    counter = counter + 1
    X.sq.S.star[counter] = stat.star
  }
  p.value.boot = mean(X.sq.S.star >= stat)
  return(list(p_value=p.value.boot, X.sq=X.sq.S.star))
}

cal_p_boot(ATL_dropna, X=12)

```



