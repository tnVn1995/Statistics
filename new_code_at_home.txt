library(foreign)
library(tidyverse)
install.packages("magrittr") # package installations are only needed the first time you use it
install.packages("dplyr")    # alternative installation of the %>%
library(magrittr) # needs to be run every time you start R and want to use %>%
library(dplyr)
file_path = 'C:/Users/tnguy/OneDrive - Texas Tech University/Summer_Project/2012 NHIS Adult Sample_CAM_HIT paper 2017-2-17.sav'
###Load in dataset
data = read.spss(file_path, to.data.frame=TRUE)


### ALT data
###------
ALT = data %>% select('ALT_TP31', 'ALT_TP32', 'ALT_TP33')


### TP_REC
### ----
Tp_REC = data %>% select('TP1_REC1', 'TP1_REC2', 'TP1_REC3', 'TP1_REC4')



### 1_INFF
### -----
TP_INF = data %>% select(TP1_INF1, TP1_INF2, TP1_INF3, TP1_INF4, TP1_INF5, TP1_INF6)




###----

### Select 2 factors of interest which are ALT_TP and TP_REC
ALT_Tp = data %>% select('TP1_REC1', 'TP1_REC2', 'TP1_REC3', 'TP1_REC4','TP2_REC1', 'TP2_REC2', 'TP2_REC3', 'TP2_REC4',
                         'TP3_REC1', 'TP3_REC2', 'TP3_REC3', 'TP3_REC4','ALT_TP31', 'ALT_TP32', 'ALT_TP33')

### Handling missing data
##----- 
#Drop NA from the data
ATL_dropna = na.omit(ALT_Tp)



## Catergorical Encoding
## ----
for (i in colnames(ATL_dropna)){
  ATL_dropna[i] = as.numeric(unlist(ATL_dropna[i]))
}

### Calculate chi
# 1 = Yes; 2 = No;
cal_X_squ = function(data){
n = dim(data)[1]
yp_i = matrix(0, nrow=1,ncol=4)
np_i = matrix(0, nrow=1, ncol=4)
j_count=matrix(0,nrow=1,ncol=16)
p_j=matrix(0,nrow=1,ncol=16)
ij_count = matrix(0, nrow=4,ncol=16)
p_ij = matrix(0, nrow=4,ncol=16)
ygrand_stats = 0
ngrand_stats = 0
for (i in 1:4){
  yes_stats =0
  no_stats = 0
  nn_i = 0
  yn_i = 0
  for (indi in c(1:n)){
    # Need to refine missing data later
    # For now the denumerator will equal 3
    yni_denumerator = 3
    # calculate the number of yes corresponding to the ith value of TP_REC for each individual
    yni_numerator=sum(c(i,i+4,i+8) %in% which(data[indi,1:12]==1))
    nni_numerator=sum(c(i,i+4,i+8) %in% which(data[indi,1:12]==2))
    # Calculate the proportion of yes and nos corresponding to the ith value of TP_REC for each individual
    yn_i = yn_i + (yni_numerator / yni_denumerator)
    nn_i = nn_i + (nni_numerator / yni_denumerator)
    # Iterate through the jth therapies each individual choose to compute each jth frequency
    for (j in data[indi,13:15]){
        j_count[1,j] = j_count[1,j] + 1
        # Calculate the frequency of individuals who choose ith rec and jth therapy
        if (sum(c(i,i+4,i+8) %in% which(data[indi,1:12]==1)) > 0){
          ij_count[i,j] = ij_count[i,j] + 1
        }
      }
    
  }
  # the grand total proportion of yeses and nos for the ith, jth and ijth values
  yp_i[1,i] = yn_i / n
  np_i[1,i] = 1 - (yn_i / n)
  p_j = j_count / n
  p_ij[i,] = ij_count[i,] / n
  # Calculate chisquare score 
  for (therap in (1:16)){
    yes_stats = yes_stats + (p_ij[i,j] - yp_i[1,i]*p_j[1,j])^2 / yp_i[1,i]*p_j[1,j]
    no_stats = no_stats + (p_ij[i,j] - np_i[1,i]*p_j[1,j])^2 / np_i[1,i]*p_j[1,j]
  }
  # The final results
  ygrand_stats = ygrand_stats + yes_stats
  ngrand_stats = ngrand_stats + no_stats
}
return(sum(ygrand_stats,ngrand_stats))
}
#Bootstrap method to calculate p_value (resample 1999 times)
cal_p_boot = function(data, X, B.max=1999){
  stat = cal_X_squ(data=data)
  X.sq.S.star = numeric(length(B.max))
  counter = 0
  b = 0
  n = dim(data)[1]
  end = dim(data)[2]
  while(b <= B.max){
    b = b+1
  W = sample(x=1:n,size=n,replace=TRUE)
  Y = sample(x=1:n,size=n,replace = TRUE)
  data.star = cbind(ATL_dropna[W,1:X],ATL_dropna[Y,(X+1):end])
  stat.star = cal_X_squ(data.star)
  
  counter = counter + 1
  X.sq.S.star[counter] = stat.star
  }
  p.value.boot = mean(X.sq.S.star >= stat)
  return(list(p_value=p.value.boot, X.sq=X.sq.S.star))
}




